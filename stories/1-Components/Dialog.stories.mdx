import { action } from '@storybook/addon-actions';
import { Meta, Preview, Props, Story } from '@storybook/addon-docs/blocks';
import { Dialog, AlertDialog, ConfirmDialog, PromptDialog, DialogBody, DialogFooter } from '../../src/components/Dialog';
import { Button } from '../../src/components/Button';

<Meta title='Components/Dialog'/>

# Dialog

**This is not a React component.**

I deviated from how most other libraries manages dialogs. Instead of having a component mounted on DOM that opens
up when the prop `open` is set to true. I created a class whose instance can be created and opened. This way the
developer doesn't need to do a lot of handling, it is just a few function calls that can be done in a few lines.

<Preview style={{ background: 'linear-gradient(to right, #00b09b, #96c93d)' }}>
    <Button
        onClick={() => AlertDialog({
            header: 'ðŸ“£ Attention!',
            body: 'This is just a async function call. No need to manage dialog state in your application.',
            buttonText: 'Got it!'
        })}
    >Alert Dialog</Button>
    <Button
        onClick={() => ConfirmDialog({
            header: 'ðŸ’­ Feedback',
            body: `
                The confirmation dialog is a async function call and results are returned via promise.
                This means that there is no need to maintain dialog state in your application.
                Do you think that this will help you keep your code clean and save time?
            `
        }).then(
            () => alert('Thanks! Glad you like it'),
            () => alert('Hmmm... Give it a try atleast.')
        )}
    >Confirm Dialog</Button>
    <Button
        onClick={() => PromptDialog({
            header: 'Bulk Order',
            defaultValue: 1,
            body: 'Thanks for your interest in this product. If you like, you can place order multiple quantity.',
            inputProps: {
                label: 'Enter Quantity',
                type: 'number',
                min: 1,
                max: 10,
                required: true
            }
        }).then(resp => alert(`Order placed for ${resp} products.`))}
    >Prompt Dialog</Button>
    <Button
        onClick={() => {
            const dialog = new Dialog({
                body: (
                    <>
                    <DialogBody>
                        Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut
                        labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris
                        nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit
                        esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt
                        in culpa qui officia deserunt mollit anim id est laborum.
                    </DialogBody>
                    <DialogFooter>
                        <Button onClick={() => dialog.close()}>Close Dialog</Button>
                    </DialogFooter>
                    </>
                ),
            });
            dialog.open();
        }}
    >Open Dialog</Button>
</Preview>

How will this help? Well often we need to take confirmation from the user before doing a destructive action or an
action where we need to double check. Imagine creating a component and keeping it in the render function. Then the
user performs an action and on that you need to open this dialog. Finally, when user responds then you need to catch
that in an `onClick` handler and then dispatch the final action. Here you will need at least 3 functions to maintain
the state of the dialog. First, you will have a render function where you will render the dialog. Then you will have
the actual event handler that the user can trigger which in turn needs to trigger state change to open the dialog.
Finally, when user responds you need to update the state to close the dialog and dispatch action based on user action.

In no frills ui you don't need to do that. When user performs an action, you can just call the confirm dialog which
will return a promise and when the user responds, the promise will be resolved or rejected accordingly. Making the
entire process seemless for the developer. We also export `DialogBody` and `DialogFooter` to help with styling.

There are following 4 Dialog function that you can use.

### `AlertDialog`

This can be used to show certain information to the user.

```jsx
import { AlertDialog, Button } from 'no-frills-ui';

const alertUser = () => {
    AlertDialog({
        body: 'Information for the user.'
    });
}

// Render
<Button onClick={alertUser}>Show Alert</Button>
```

```typescript
interface AlertOption {
    /** Shown as header of the dialog */
    header?: string | JSX.Element,
    /** Rendered in the body. */
    body: string | JSX.Element,
    /** Accept button text, default value is `OK` */
    buttonText?: string,
    /** props for the dialog */
    props?: object,
}
```

### `ConfirmDialog`

This can be used for confirmation before performing certain action.

```jsx
import { ConfirmDialog, Button } from 'no-frills-ui';

const confirm = async () => {
    try {
        const resp = await ConfirmDialog({
            body: 'Are you sure?'
        });
        // Proceed with the action.
    } catch (e) {
        // User rejected the confirmation. Fallback.
    }
}

// Render
<Button onClick={confirm}>Show Confirmation</Button>
```

```typescript
interface ConfirmOption {
    /** Shown as header of the dialog */
    header?: string | JSX.Element,
    /** Rendered as body of the dialog */
    body: string | JSX.Element,
    /** Accept button text */
    yesText?: string,
    /** Reject button text */
    noText?: string,
    /** Props for the dialog */
    props?: object,
}
```

### `PromptDialog`

This can be used to prompt user for some additional information.

```jsx
import { PromptDialog, Button } from 'no-frills-ui';

const promptUser = async () => {
    try {
        const resp = await PromptDialog();
        // resp contains user's response.
    } catch (e) {
        // User rejected the prompt. Fallback.
    }
}

// Render
<Button onClick={promptUser}>Show Prompt</Button>
```

```typescript
interface PromptOption {
    /** Shown as header of the dialog */
    header?: string | JSX.Element,
    /** Rendered as the body of the dialog */
    body?: string,
    /** Default value for the input. */
    defaultValue?: string,
    /** Submit button text. Default value is 'Submit' */
    submitText?: string,
    /** Cancel button text. Default value is 'Cancel' */
    cancelText?: string,
    /** Props for the input. */
    inputProps?: object,
    /** Props for the dialog. */
    props?: object,
}
```
### `Dialog`

Fully customizable dialog. This works on call backs and not promise. This is because there are two possible actions.
1. User closes the dialog by some action.
2. Dialog was closed programmatically.

You can easily wrap this in a promise depending on the use case or use it as is.

```jsx
import { Dialog, Button } from 'no-frills-ui';

const showDialog = () => {
    // Create instance of the dialog.
    const dialog = new Dialog({
        body: 'Come to the dark side Luke!'
    });

    // Open dialog.
    const closeFn = dialog.open();
}

// Render
<Button onClick={showDialog}>Show Dialog</Button>
```

```typescript
interface DialogOptions {
    /** Shown as header of the dialog */
    header?: string | JSX.Element;
    /** Rendered as the body of the dialog */
    body: string | JSX.Element;
    /** Flag to close dialog on `esc` click. Default value is true. */
    closeOnEsc?: boolean;
    /** Close layer overlay is clicked. Default value is true. */
    closeOnOverlayClick?: boolean;
    /** Callback function that is called when dialog is closed. */
    closeCallback?: () => void;
    /** Props for the dialog. */
    props?: object;
}
```
